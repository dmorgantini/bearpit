import {FairnessAnalyzer} from "./fairness-analyzer.js";
import {distributions} from "./distributions.js";

function analyzeMemoryEfficientTournamentFairness() {
  const baseConfig = {
    skillMultiplier: 3.0,
    fatigueMultiplier: 0.005,
    baseSimulChance: 0.15,
    simulReductionPerLevel: 0.02,
    averageFightDurationSeconds: 30,
    fightDurationVariance: 10,
    restPeriodSeconds: 30
  };
  
  // Reduced scope to prevent memory issues
  const fighterCounts = [8, 12, 16, 20, 24, 30, 40, 60];
  
  const tournamentModes = [
    { name: 'Traditional', config: {} },
    { name: 'Race to 3 Wins', config: { retirementStreakLength: 3, maxRetirements: 3 } },
    { name: 'Race to 5 Wins', config: { retirementStreakLength: 5, maxRetirements: 3 } },
    { name: 'Race to 7 Wins', config: { retirementStreakLength: 7, maxRetirements: 3 } },
    { name: 'Race to Auto Wins', config: { retirementStreakLength: 'auto', maxRetirements: 3 } }
  ];

  let markdownOutput = '';

  // Header
  markdownOutput += '# Boffer Foam Tournament Configuration Guide\n\n';
  markdownOutput += 'Generated by Tournament Fairness Analyzer  \n';
  markdownOutput += `Analysis Date: ${new Date().toLocaleDateString()}\n\n`;
  
  // Configuration section
  markdownOutput += '## Simulation Parameters\n\n';
  markdownOutput += `- **Skill Multiplier:** ${baseConfig.skillMultiplier}x per level difference\n`;
  markdownOutput += `- **Fatigue Rate:** ${baseConfig.fatigueMultiplier} reduction per win streak\n`;
  markdownOutput += `- **Base Simul Chance:** ${(baseConfig.baseSimulChance * 100)}%\n`;
  markdownOutput += `- **Simul Reduction:** ${(baseConfig.simulReductionPerLevel * 100)}% per level difference\n`;
  markdownOutput += `- **Fight Duration:** ${baseConfig.averageFightDurationSeconds}±${baseConfig.fightDurationVariance} seconds\n`;
  markdownOutput += `- **Rest Period:** ${baseConfig.restPeriodSeconds} seconds between fights\n`;
  markdownOutput += `- **Iterations per test:** 25-50 simulations\n\n`;
  
  // Store only final recommendations, not all intermediate data
  const finalRecommendations = new Map();
  
  let totalTests = fighterCounts.length * distributions.length * tournamentModes.length;
  let currentTest = 0;

  // Process one fighter count at a time to manage memory
  fighterCounts.forEach(fighterCount => {
    console.log(`ANALYZING ${fighterCount} FIGHTERS...`);
    
    // Store results for this fighter count
    const fighterCountRecommendations = new Map();
    
    distributions.forEach((distribution, distIndex) => {
      let bestOverallForThisDistribution = null;
      
      // Test each tournament mode for this distribution + fighter count
      tournamentModes.forEach((mode, modeIndex) => {
        currentTest++;
        
        const modeConfig = { ...baseConfig, ...mode.config };
        
        try {
          // Generate fighters - use smaller scope to prevent memory buildup
          const distributionFighters = generateFightersFromDistribution(fighterCount, distribution.dist);
          const analyzer = new FairnessAnalyzer(distributionFighters, null, modeConfig);
          
          // Reduced analysis scope to save memory
          const timeOptions = [10, 15, 20, 25]; // Fewer time options
          const maxPits = Math.min(Math.floor(fighterCount / 6), 4); // Fewer pit options, at least 4 fighters per pit
          const pitOptions = [];
          for (let pits = 1; pits <= maxPits; pits++) {
            pitOptions.push(pits);
          }
          const queueOptions = [false]; // Only shared queue to save memory
          
          // Suppress output during analysis
          const originalLog = console.log;
          console.log = () => {};
          
          // Fewer iterations for larger fighter counts
          const iterations = 50;
          const modeResults = analyzer.analyzeFairness(timeOptions, pitOptions, queueOptions, iterations);
          
          console.log = originalLog;
          
          const bestConfig = modeResults[0];
          
          // Only keep the best result for this mode, discard the rest
          const modeResult = {
            mode: mode.name,
            distribution: distribution.name,
            fighterCount: fighterCount,
            score: bestConfig.optimizedScore,
            config: bestConfig.configuration,
            cv: bestConfig.averageMetrics.fightDistribution.fightDistributionCV,
            avgFights: bestConfig.averageMetrics.fightDistribution.avgFightsPerFighter,
            skillCorrelation: bestConfig.averageMetrics.competitiveBalance.skillWinCorrelation,
            // Store the key configuration details
            time: bestConfig.configuration.time,
            pits: bestConfig.configuration.pits,
            totalFights: bestConfig.averageMetrics.rawStats.totalFights,
            simulRate: bestConfig.averageMetrics.efficiency.simulRate
          };
          
          // Track best for this distribution
          if (!bestOverallForThisDistribution || modeResult.score > bestOverallForThisDistribution.score) {
            bestOverallForThisDistribution = modeResult;
          }
          
          // Force garbage collection after each mode test
          if (global.gc) {
            global.gc();
          }
          
        } catch (error) {
          console.log(`ERROR: ${error.message}`);
        }
      });
      
      // Store only the best recommendation for this fighter count + distribution
      if (bestOverallForThisDistribution) {
        fighterCountRecommendations.set(distribution.name, bestOverallForThisDistribution);
      }
    });
    
    // Store recommendations for this fighter count
    finalRecommendations.set(fighterCount, fighterCountRecommendations);
  });
  
  console.log('ANALYSIS COMPLETE');
  
  // MAIN RECOMMENDATION TABLES
  markdownOutput += '## Tournament Configuration Recommendations\n\n';
  
  // Simple lookup table
  markdownOutput += '### Quick Reference Table\n\n';
  markdownOutput += 'Fighter Count → Best Tournament Mode\n\n';
  
  const modeCounters = new Map();
  fighterCounts.forEach(fighterCount => {
    const modeFrequency = new Map();
    
    distributions.forEach(distribution => {
      const rec = finalRecommendations.get(fighterCount)?.get(distribution.name);
      if (rec) {
        modeFrequency.set(rec.mode, (modeFrequency.get(rec.mode) || 0) + 1);
      }
    });
    
    // Find most common mode for this fighter count
    let bestMode = 'Unknown';
    let maxCount = 0;
    modeFrequency.forEach((count, mode) => {
      if (count > maxCount) {
        maxCount = count;
        bestMode = mode;
      }
    });
    
    markdownOutput += `- **${fighterCount} fighters:** ${bestMode} (${maxCount}/${distributions.length} scenarios)\n`;
    modeCounters.set(bestMode, (modeCounters.get(bestMode) || 0) + 1);
  });
  
  markdownOutput += '\n';
  
  // Main configuration matrix with time and pits
  markdownOutput += '### Best Configuration for Each Fighter Count × Distribution\n\n';
  markdownOutput += '| Distribution | ' + fighterCounts.map(c => c.toString()).join(' | ') + ' |\n';
  markdownOutput += '| --- | ' + fighterCounts.map(() => '---').join(' | ') + ' |\n';
  
  distributions.forEach(distribution => {
    const row = [distribution.name];
    
    fighterCounts.forEach(fighterCount => {
      const recommendation = finalRecommendations.get(fighterCount)?.get(distribution.name);
      if (recommendation) {
        // Create compact display: Mode/Time/Pits
        const shortMode = recommendation.mode
          .replace('Race to ', 'R')
          .replace(' Wins', '')
          .replace('Traditional', 'Tr')
          .replace('Auto', 'A');
        const configStr = `${shortMode}/${recommendation.time}m/${recommendation.pits}p`;
        row.push(configStr);
      } else {
        row.push('ERROR');
      }
    });
    
    markdownOutput += '| ' + row.join(' | ') + ' |\n';
  });
  
  markdownOutput += '\n**Legend:** Tr=Traditional, R3=Race to 3, R5=Race to 5, R7=Race to 7, RA=Race to Auto  \n';
  markdownOutput += 'Format: Mode/TimeMinutes/PitCount (e.g., R5/20m/2p = Race to 5 Wins, 20 minutes, 2 pits)\n\n';
  
  // Detailed configuration table by fighter count
  markdownOutput += '### Detailed Configuration by Fighter Count\n\n';
  
  fighterCounts.forEach(fighterCount => {
    markdownOutput += `#### ${fighterCount} Fighters\n\n`;
    
    // Create a clean table for this fighter count
    const tableData = [];
    distributions.forEach(distribution => {
      const rec = finalRecommendations.get(fighterCount)?.get(distribution.name);
      if (rec) {
        tableData.push({
          distribution: distribution.name,
          mode: rec.mode,
          time: rec.time,
          pits: rec.pits,
          avgFights: rec.avgFights.toFixed(1),
          fairnessScore: rec.score.toFixed(0)
        });
      }
    });
    
    // Print clean table
    markdownOutput += '| Distribution | Mode | Time | Pits | Avg Fights | Score |\n';
    markdownOutput += '| --- | --- | ---: | ---: | ---: | ---: |\n';
    tableData.forEach(row => {
      markdownOutput += `| ${row.distribution} | ${row.mode} | ${row.time} | ${row.pits} | ${row.avgFights} | ${row.fairnessScore} |\n`;
    });
    
    markdownOutput += '\n';
  });
  
  // Distribution-specific recommendations
  markdownOutput += '## Recommendations by Skill Distribution\n\n';
  
  distributions.forEach(distribution => {
    markdownOutput += `### ${distribution.name}\n\n`;
    
    // Show skill breakdown
    markdownOutput += '**Skill Breakdown:**\n';
    Object.entries(distribution.dist).forEach(([level, percentage]) => {
      markdownOutput += `- Level ${level}: ${(percentage * 100).toFixed(0)}%\n`;
    });
    markdownOutput += '\n';
    
    markdownOutput += '**Recommended Configurations:**\n\n';
    markdownOutput += '| Fighter Count | Mode | Time | Pits | Setup |\n';
    markdownOutput += '| ---: | --- | ---: | ---: | --- |\n';
    
    fighterCounts.forEach(fighterCount => {
      const rec = finalRecommendations.get(fighterCount)?.get(distribution.name);
      if (rec) {
        const setup = `${rec.time}min/${rec.pits}pit${rec.pits > 1 ? 's' : ''}`;
        markdownOutput += `| ${fighterCount} | ${rec.mode} | ${rec.time} | ${rec.pits} | ${setup} |\n`;
      }
    });
    
    markdownOutput += '\n';
  });
  
  // Summary insights
  markdownOutput += '## Key Insights and Recommendations\n\n';
  
  markdownOutput += '### Overall Mode Effectiveness\n\n';
  Array.from(modeCounters.entries())
    .sort(([,a], [,b]) => b - a)
    .forEach(([mode, count]) => {
      const percentage = ((count / fighterCounts.length) * 100).toFixed(0);
      markdownOutput += `- **${mode}:** Recommended for ${count}/${fighterCounts.length} fighter counts (${percentage}%)\n`;
    });
  
  markdownOutput += '\n';
  
  // Time and pit insights
  const timePreferences = new Map();
  const pitPreferences = new Map();
  
  finalRecommendations.forEach(fighterCountMap => {
    fighterCountMap.forEach(recommendation => {
      timePreferences.set(recommendation.time, (timePreferences.get(recommendation.time) || 0) + 1);
      pitPreferences.set(recommendation.pits, (pitPreferences.get(recommendation.pits) || 0) + 1);
    });
  });
  
  markdownOutput += '### Time Duration Preferences\n\n';
  Array.from(timePreferences.entries())
    .sort(([,a], [,b]) => b - a)
    .forEach(([time, count]) => {
      const total = fighterCounts.length * distributions.length;
      const percentage = ((count / total) * 100).toFixed(0);
      markdownOutput += `- **${time} minutes:** Used in ${count} scenarios (${percentage}%)\n`;
    });
  
  markdownOutput += '\n';
  
  markdownOutput += '### Pit Count Preferences\n\n';
  Array.from(pitPreferences.entries())
    .sort(([a], [b]) => a - b)
    .forEach(([pits, count]) => {
      const total = fighterCounts.length * distributions.length;
      const percentage = ((count / total) * 100).toFixed(0);
      markdownOutput += `- **${pits} pit${pits > 1 ? 's' : ''}:** Used in ${count} scenarios (${percentage}%)\n`;
    });
  
  markdownOutput += '\n';
  
  // Practical guidance
  markdownOutput += '## Practical Tournament Setup Guide\n\n';
  
  markdownOutput += '1. **Count your fighters and assess skill levels**\n';
  markdownOutput += '2. **Find your scenario in the tables above**\n';
  markdownOutput += '3. **Set up your tournament with the recommended:**\n';
  markdownOutput += '   - Tournament mode (Traditional vs Race to X Wins)\n';
  markdownOutput += '   - Time duration\n';
  markdownOutput += '   - Number of pits\n\n';
  
  markdownOutput += '### Tournament Mode Explanations\n\n';
  
  markdownOutput += '#### Traditional\n';
  markdownOutput += 'Standard bear pit tournament\n';
  markdownOutput += '- Run for the full time duration\n';
  markdownOutput += '- Winner is fighter with longest win streak\n';
  markdownOutput += '- All fighters participate for the entire time\n\n';
  
  markdownOutput += '#### Race to X Wins\n';
  markdownOutput += 'First-to-finish tournament\n';
  markdownOutput += '- First 3 fighters to reach X consecutive wins retire as winners\n';
  markdownOutput += '- Tournament ends when 3 fighters retire or time expires\n';
  markdownOutput += '- Creates urgency and excitement\n';
  markdownOutput += '- Prevents extremely long win streaks\n\n';
  
  markdownOutput += '#### Race to Auto Wins\n';
  markdownOutput += 'Adaptive win target\n';
  markdownOutput += '- Win target automatically calculated based on average skill level\n';
  markdownOutput += '- Formula: (Average Level × 2) + 1\n';
  markdownOutput += '- Scales difficulty to match your group\n\n';
  
  markdownOutput += '## Configuration Parameters Used\n\n';
  markdownOutput += `- **Skill Multiplier:** ${baseConfig.skillMultiplier}\n`;
  markdownOutput += '  - Each level difference multiplies win chance by this amount\n';
  markdownOutput += '  - Higher values make level differences more important\n\n';
  markdownOutput += `- **Fatigue Multiplier:** ${baseConfig.fatigueMultiplier}\n`;
  markdownOutput += '  - Win chance reduction per consecutive win in streak\n';
  markdownOutput += '  - Prevents runaway win streaks\n\n';
  markdownOutput += `- **Base Simul Rate:** ${(baseConfig.baseSimulChance * 100)}%\n`;
  markdownOutput += '  - Baseline chance for both fighters to be eliminated\n';
  markdownOutput += '  - Reduced by level differences\n\n';
  markdownOutput += `- **Fight Duration:** ${baseConfig.averageFightDurationSeconds}±${baseConfig.fightDurationVariance} seconds\n`;
  markdownOutput += '  - Average fight length with variance\n\n';
  markdownOutput += `- **Rest Period:** ${baseConfig.restPeriodSeconds} seconds\n`;
  markdownOutput += '  - Minimum time before fighter can fight again\n\n';
  
  markdownOutput += '---\n\n';
  markdownOutput += '*Generated by Boffer Tournament Fairness Analyzer*  \n';
  markdownOutput += `*Analysis completed: ${new Date().toLocaleString()}*\n`;
  
  // Output the markdown to console
  console.log('\n' + markdownOutput);
  
  return finalRecommendations;
}

function generateFightersFromDistribution(totalFighters, distribution) {
  const fighters = [];
  let fighterIndex = 1;
  
  // Convert percentages to actual fighter counts
  Object.entries(distribution).forEach(([level, percentage]) => {
    const count = Math.round(totalFighters * percentage);
    for (let i = 0; i < count; i++) {
      fighters.push({
        name: `Fighter${fighterIndex}`,
        level: parseInt(level)
      });
      fighterIndex++;
    }
  });
  
  // Adjust if we're short or over
  while (fighters.length < totalFighters) {
    fighters.push({
      name: `Fighter${fighterIndex}`,
      level: 1
    });
    fighterIndex++;
  }
  
  return fighters.slice(0, totalFighters);
}

// Run with memory monitoring
function runMemoryEfficientAnalysis() {
  try {
    console.log('Generating Markdown tournament guide...');
    console.log('');
    
    // Enable garbage collection if available
    if (global.gc) {
      console.log('Garbage collection enabled - run with --expose-gc for optimal memory usage');
    }
    
    const results = analyzeMemoryEfficientTournamentFairness();
    
    return results;
  } catch (error) {
    console.error('Analysis failed:', error);
    if (error.message.includes('heap')) {
      console.error('');
      console.error('MEMORY TIPS:');
      console.error('1. Run with: node --max-old-space-size=4096 fairness_analysis_runner.js');
      console.error('2. Or reduce fighterCounts array further');
      console.error('3. Or reduce iterations in the analysis');
    }
  }
}

runMemoryEfficientAnalysis();